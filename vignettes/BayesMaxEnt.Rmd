---
title: "Simple Use of BayesMaxEnt"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Simple Use of BayesMaxEnt}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, message=FALSE}
library(BayesMaxEnt)
library(disdat)
library(bayesplot)
library(parallel)
```


Set up the data

``` {r run_examples}
CAN <- disData("CAN")
EnvPO <- c("alt", "asp2", "ontprec", "ontprec4", "ontprecsd", "ontslp", 
           "onttemp", "onttempsd", "onttmin4", "ontveg", "watdist")
Species <- "can02"

SpData <- rbind(CAN$po[CAN$po$spid==Species,c("occ", EnvPO)], CAN$bg[,c("occ", EnvPO)])
SpData[,EnvPO] <- apply(SpData[,EnvPO], 2, scale) # scale covariates
```

Because Nimble wants the data in its own format, we have a function to do the conversion. here we just use linear features, rather than everything MaxEnt wants to throw at the data.

```{r SetUpData, message=FALSE, results='hide'}
ToNimble <- SetUpMaxEnt(p=SpData$occ, data=SpData[,EnvPO], 
                        regmult = 1, lambda=0.1, classes="l")
```

We run a relatively short set of chains, to save time. 

```{r RunModel, message=FALSE, results='hide', eval=TRUE, error=FALSE}
nburn <- 1e3; niter <- 1e3
output <- FitMaxEnt(maxdat=ToNimble, parallel = TRUE, adaptInterval=nburn,
                     nchains=2, nburnin = nburn, niter=nburn+niter, thin=1)

```

With `r niter` iterations we cannot see much, but at least we are getting some numbers. 
For a real analysis a longer burn-in is needed.

```{r PlotOutput, eval=TRUE, fig.width=8}
mcmc_trace(output, pars = c("alpha", "beta[1]"))
```

